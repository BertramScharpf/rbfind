#!/usr/bin/ruby

#
#  rbfind  --  Ruby Find with many features
#

require "rbfind"

PROGRAM = <<EOT
rbfind #{RbFind::VERSION}  --  A find tool using Ruby

  Author: Bertram Scharpf <software@bertram-scharpf.de>
  License: BSD
EOT


require 'getoptlong'

OPTIONS = [
  #    options          arg   description
  [ %w(--help      -h), nil,  "print this help"],
  [ %w(--examples  -X), nil,  "print this help and examples"],
  [ %w(--version   -V), nil,  "print version information"],
  [ %w(--verbose   -v), nil,  "standard Ruby error reports"],
  [ %w(--show      -o), nil,  "just show Ruby block built from options"],
  [ %w(--bw        -w), nil,  "black and white on -p or default output"],
  [ %w(--colored   -c), nil,  "force color on -p or default output"],
  [ %w(--depth     -d), nil,  "yield directory after its contents"],
  [ %w(--maxdepth  -m), :num, "maxium step depth"],
  [ %w(--follow    -y), nil,  "follow symbolic links"],
  [ %w(--sort      -s), :str, "=reverse/desc/-1,unsorted; default is sorted"],
  [ %w(--sort-by   -S), :str, "sort expression ('name' is name)"],
  [ %w(--require   -r), :rb,  "require library"],
  [ %w(--fileutils -U), nil,  "include FileUtils module"],
  [ %w(--puts-path -p), nil,  "do 'puts path/cpath' on true block"],
  [ %w(--ls-l      -P), nil,  "do \"ls -l\" style output on true block"],
  [ %w(--lines     -l), :blk, "surround block by 'lines { |$_,$.| ... }'"],
  [ %w(--reallines -L), :blk, "same as -l but stop at any null character"],
  [ %w(--grep      -g), :blk, "grep files (implies -pL)"],
  [ %w(--igrep     -G), :blk, "case insensitive grep"],
  [ %w(--binary    -b), nil,  "grep even binary files"],
  [ %w(--no-vcs    -C), nil,  "prune version control dirs (CVS/.svn/.git)"],
  [ %w(--no-swap   -W), nil,  "ignore Vim swapfiles"],
  [ %w(--skip      -k), :lst, "filenames to skip"],
  [ %w(--demand    -D), :lst, "skip all filenames but these"],
  [ %w(--ext       -e), :lst, "skip all filename extensions but these"],
  [ %w(--visible   -I), nil,  "skip all hidden (starting with .dot)"],
  [ %w(--begin     -B), :blk, "BEGIN block"],
  [ %w(--end       -E), :blk, "END block"],
  [ %w(--file      -f), :blk, "read block expression from file"],
]

def usage
  puts <<EOT
Usage:

  rbfind [options] path... 'block'

EOT
  OPTIONS.each { |(long,short),arg,desc|
    puts "    %-12s %2s  %-5s  %s" % [long,short,arg.to_s.upcase,desc]
  }
  puts <<'EOT'

  "--" stops option processing.

  The last argument is a block that will be executed on every found
  file object. It may be omitted; then "puts path" is assumed or "cpath"
  in case the output is a terminal.

  Default sort order is alphabetical.

EOT
end

def usage_examples
  usage
  puts <<'EOT'
Examples:
  $ rbfind -p 'file and age < 5.m'
  $ rbfind -p 'file and age > 1.d'
  $ rbfind -p '(90.d .. 183.d) === age'

  $ rbfind -Cg require
  $ rbfind -Cp
  $ rbfind 'filesize < 100.kB and grep /require/'
  $ rbfind -g 'define\s*ALLOC_N'
  $ rbfind myproject -e rb -l '~/require/ and puts $_'

  $ rbfind -pe '.rb c h'
  $ rbfind /usr/include -e .h -g EACCES
  $ rbfind -d -m3 -- /mnt/data
  $ rbfind 'filesize > 10.MiB and colsep size.to_hib, path'

  $ rbfind -S "name =~ /^\.*/ ; $'.downcase"
  $ rbfind -B '$s=0' -E 'puts $s.to_h' 'filesize {|s|$s+=s}'
  $ rbfind 'puts path if ext == ".rb"'
  $ rbfind -p 'ext == ".rb"'
  $ rbfind /usr/include -p -D '\.h$' -l '~/EACCES/'
  $ rbfind /usr/include -pD 'pg|pq|postgres' dir
  $ rbfind 'no_svn ; puts path'
  $ rbfind 'prune if name == ".svn" ; puts path'
  $ rbfind -p 'prune if name == ".svn"'
  $ rbfind myproject 'name[/\.rb$/] and lines { |l,i| l=~/require/ and puts l }'
  # rbfind /etc 'lines { |l,| l["192.168."] and (puts path ; break) }'
  $ rbfind /etc 'readable? or raise "Access denied: #{path}" ;
  >              lines { |l,| l["192.168."] and (puts path ; break) }'

  $ rbfind 'col_sep stype+modes, size[10], path'
  $ rbfind 'tab_sep stype+modes, size[10], path'
  $ rbfind 'spc_sep stype+modes, size.to_h, user, group, mtime.lsish, path'
  $ rbfind 'spacesep stype+modes, size.to_h, user, group, mtime.lsish, path'
  $ rbfind 'spacesep stype+modes, size.to_h, user, group, mtime!, path'
  $ rbfind 'spacesep stype+modes, size.to_h, user, group, mtime.i, path'
  $ rbfind 'spacesep mtime.u, path'
  $ rbfind 'spacesep modes, user|8, group|8, size[8], cpath + carrow.to_s'

  $ rbfind 'spacesep digest_md5, size[8], path'
  $ rbfind 'spacesep digest_sha256, size[8], path'

  $ rbfind 'rename name.downcase'
  $ rbfind 'ext == ".tgz" and rename without_ext+".tar.gz"'

  See the RbFind class documentation or the "rbfind.rb" source file for more
  sophisticated examples and for a full list of file examination methods.

  Valid units are 1.s, 1.m, 1.h, 1.d, 1.w for time values and
  1.kB == 1000, 1.kiB == 1024, 1.MB, 1.MiB for file sizes.
EOT
end


require "humansiz"
require "English"


class Time

  # autoload several formating methods
  def method_missing sym, *args, &block
    if require "time" then
      send sym, *args, &block
    else
      super
    end
  end

  # several common schemes
  def i ; iso8601   ; end
  def x ; xmlschema ; end
  def r ; rfc822    ; end
  def u ; utc.strftime "%Y-%m-%d %H:%M:%S" ; end

end


class Fixnum
  # convenient formatting, right justification
  def [] width
    "%#{width.to_i}d" % self
  end
end

class String
  # convenient formatting, left justification
  def | width
    ljust width
  end
end

class NilClass
  # This makes it very easy to compare the return value of `filesize'.
  def <  oth ; false ; end
  def <= oth ; false ; end
  def >  oth ; false ; end
  def >= oth ; false ; end
  def between? min, max ; false ; end

  def [] width ; " "*width ; end
  def |  width ; " "*width ; end
end

class RbFindX < RbFind

  # Alias the question marks away from all method names because
  # they're a nuisance on the command line.
  alias hidden       hidden?
  alias visible      visible?
  alias broken_link  broken_link?
  alias dir          dir?
  alias binary       binary?
  alias bin          bin?
  alias vimswap      vimswap?

  def blockdev        ; blockdev?         ; end
  def chardev         ; chardev?          ; end
  def directory       ; directory?        ; end
  def executable      ; executable?       ; end
  def executable_real ; executable_real?  ; end
  def file            ; file?             ; end
  def grpowned        ; grpowned?         ; end
  def owned           ; owned?            ; end
  def pipe            ; pipe?             ; end
  def readable        ; readable?         ; end
  def readable_real   ; readable_real?    ; end
  def setgid          ; setgid?           ; end
  def setuid          ; setuid?           ; end
  def socket          ; socket?           ; end
  def sticky          ; sticky?           ; end
  def symlink         ; symlink?          ; end
  def writable        ; writable?         ; end
  def writable_real   ; writable_real?    ; end
  def zero            ; zero?             ; end

  # convenient digest and time format methods
  def method_missing sym, *args, &block
    case sym.to_s
      when /\Adigest_(.*)/ then
        m = $1
        c = m.upcase
        begin
          (Digest.const_get c).hexdigest read
        rescue NameError
          if m =~ /sha\d\d\d/ then m = "sha2" end
          require "digest/#{m}" and retry
        end
      when /\A([amc]time)!\z/ then
        (send $1).strftime "%Y-%m-%d %H:%M:%S %z"
      else
        super
    end
  end

end


def error_handle
  if @verbose then
    yield
  else
    begin
      yield
    rescue
      $stderr.puts "#{$!.class}: #$!"
      exit 1
    rescue NoMemoryError, ScriptError, SignalException
      $stderr.puts $!.inspect
      exit 2
    end
  end
end


@params = {}

opts = GetoptLong.new *OPTIONS.map { |(long,short),arg,|
  [long,short,(arg ? GetoptLong::REQUIRED_ARGUMENT : GetoptLong::NO_ARGUMENT)]
}
opts.ordering = GetoptLong::PERMUTE
opts.quiet = true
begin
  opts.each do |opt,arg|
    case opt
      when '--help'      then usage          ; exit
      when '--version'   then puts PROGRAM   ; exit
      when '--examples'  then usage_examples ; exit
      when '--verbose'   then @verbose = true
      when '--show'      then @show = true
      when '--bw'        then @color = false
      when '--colored'   then @color = true
      when '--depth'     then @params[ :depth] = true
      when '--maxdepth'  then @params[ :max_depth] = arg
      when '--follow'    then @params[ :follow] = true
      when '--sort'      then @params[ :sort] = arg
      when '--sort-by'   then @params[ :sort] = instance_eval "proc { |name| #{arg} }"
      when '--require'   then require arg
      when '--fileutils' then require "fileutils" ; include FileUtils
      when '--puts-path' then @puts_path = true
      when '--ls-l'      then @puts_path = :long
      when '--lines'     then @lines = :plain ;                 @block = arg
      when '--reallines' then @lines = :plain ; @real = true ;  @block = arg
      when '--grep'      then @lines = :grep  ;                 @block = arg
      when '--igrep'     then @lines = :grep  ; @icase = true ; @block = arg
      when '--binary'    then @binary = true
      when '--no-vcs'    then @vcs = true
      when '--no-swap'   then @vim = true
      when '--skip'      then @skip = arg
      when '--demand'    then @demand = arg
      when '--ext'       then @ext = arg
      when '--visible'   then @visible = true
      when '--begin'     then @blkbegin = arg
      when '--end'       then @blkend   = arg
      when '--file'      then @block = File.read arg
    end
  end
rescue GetoptLong::InvalidOption
  $stderr.puts $!
  $stderr.puts
  usage
  exit 9
rescue
  $stderr.puts $!
  exit 8
end

@color.nil? and @color = !File::ALT_SEPARATOR&&$stdout.tty?
opath = @color ? "cpath" : "path"


case @lines
  when :plain then
    @puts_path and @block = "( #@block ) and colsep #{opath}, $., $_"
    @real and @block = "break if ~/\0/o ; #@block"
    @block = "lines { |line,num| $_, $. = line, num ; #@block }"

  when :grep then
    RE = Regexp.new @block, @icase && Regexp::IGNORECASE
    @block = "grep RE"
    @binary or @block = "not binary? and #@block"

  else
    @block ||= if $*.last and not (File.lstat $*.last rescue nil) then
      $*.pop.dup
    else
      @puts_path ||= true
      "true"
    end
    if @puts_path then
      @block = "( #@block ) and "
      @block << if @puts_path == :long then
        "spcsep stype+modes, user|6, group|6, size[6], " +
            "mtime.lsish, #{opath} + #{@color ? 'carrow' : 'arrow'}.to_s"
      else
        "puts #{opath}"
      end
    end

end

if @skip then
  RE_SKIP = Regexp.new @skip, File::ALT_SEPARATOR&&Regexp::IGNORECASE
  @block.insert 0, "next if name =~ RE_SKIP ; "
end

if @demand then
  RE_DEMAND = Regexp.new @demand, File::ALT_SEPARATOR&&Regexp::IGNORECASE
  @block.insert 0, "next unless name =~ RE_DEMAND ; "
end

if @ext then
  RE_EXT = Regexp.new '\A\.(' +
    @ext.split.map { |e| e[ /[^.]*\z/] }.join('|') + ')\z',
    File::ALT_SEPARATOR&&Regexp::IGNORECASE
  @block.insert 0, "ext =~ RE_EXT or next ; "
end

@visible and @block.insert 0, "visible? or prune ; "

@vcs and @block.insert 0, "no_vcs ; "
@vim and @block.insert 0, "vimswap? and next ; "

eval "BEGIN { #@blkbegin }" if @blkbegin
eval "END   { #@blkend   }" if @blkend

args = $*.dup
args.push $stdin.read.map { |l| l.chomp } unless args.any? or $stdin.tty?

if @show then
  class Proc
    def to_s
      "#<%s:0x%08x>" % [ self.class, object_id]
    end
  end
  INDENT = " "*2
  def puts_val *args
    l = [ INDENT, *args].join ""
    puts l
  end
  puts "arguments:"
  args.each { |a| puts_val a }.any?              or puts_val "(none)"
  puts "parameters:"
  @params.each { |k,v| puts_val k, "=", v }.any? or puts_val "(none)"
  puts "block:"
  self.class.constants.grep( /^RE(_[A-Z]+)?$/).each { |re|
    v = self.class.const_get re
    puts_val re, "=", v
  }
  puts_val @block
  exit
end

if @color then
  def show_error e
    $stderr.puts "\e[31m#{e.class}: \e[1m#{e}\e[m"
  end
else
  def show_error e
    $stderr.puts "#{e.class}: #{e}"
  end
end

@params[ :error] = proc do
  case $!
    when Errno::EPIPE then raise
    else                   show_error $!
  end
end

@block = <<EOT
handle_error do
  #@block
end
EOT

error_handle do
  RbFindX.open args, @params do |f| f.instance_eval @block end
end

