#!/usr/bin/env ruby
#!/usr/bin/ruby

#
#  rbfind  --  Ruby Find with many features
#

require "rbfind"
require "rbfind/humansiz"
require 'rbfind/appl'


module RbFind

  class RbFindAppl < Application

    PROGRAM = <<~EOT
      rbfind #{RbFind::VERSION}  --  A find tool using Ruby

        Author: Bertram Scharpf <software@bertram-scharpf.de>
        License: BSD
    EOT

    option %w(h help      ), "print this help"                            do usage          ; raise Exit ; end
    option %w(X examples  ), "print this help and examples"               do usage_examples ; raise Exit ; end
    option %w(V version   ), "print version information"                  do puts PROGRAM   ; raise Exit ; end
    option %w(v verbose   ), "standard Ruby error reports"                do @verbose = true ; end
    option %w(o show      ), "just show Ruby block built from options"    do @show = true ; end
    option %w(w bw        ), "black and white on -p or default output"    do @color = false ; end
    option %w(c colored   ), "force color on -p or default output"        do @color = true ; end
    option %w(d depth     ), "yield directory after its contents"         do @params[ :depth_first] = true ; end
    option %w(m maxdepth  ), "maxium step depth (0 = any)"                do |num| @params[ :max_depth] = num.to_i.nonzero? ; end
    option %w(A argsdepth ), "args have depth 1 (not 0)"                  do @params[ :args_depth] = true ; end
    option %w(y follow    ), "follow symbolic links"                      do @params[ :follow] = true ; end
    option %w(U nosort    ), "unsorted"                                   do @params[ :sort] = false ; end
    option %w(s sort-by   ), "sort expression"                            do |str| @params[ :sort] = instance_eval "proc { #{str} }" ; end
    option %w(R reverse   ), "reverse the sort"                           do @params[ :reverse] = !@params[ :reverse] ; end
    option %w(t time      ), "sort by time, newest first"                 do @params[ :sort] = proc { mtime } ; @params[ :reverse] = true ; end
    option %w(S size      ), "sort by size, largest first"                do @params[ :sort] = proc { size  } ; @params[ :reverse] = true ; end
    option %w(F dirs      ), "sort directories before files"              do @params[ :dirs] = true ; end
    option %w(r require   ), "require library"                            do |rb| require rb ; end
    option %w(x execute   ), "execute block"                              do |b| @block = b ; end
    option %w(p puts-path ), "do 'puts path/cpath' on true block"         do @puts = true ; end
    option %w(P ls-l      ), "do 'ls -l' style output on true block"      do @puts = :ls  ; @wds ||= 6 ; @wdu ||= 6 ; end
    option %w(Q long      ), "alternate long format on true block"        do @puts = :alt ; @wds ||= 7 ; @wdu ||= 4 ; end
    option %w(H humanage  ), "long format with human readable ages"       do @puts = :hum ; @wds ||= 7 ; @wdu ||= 4 ; end
    option %w(J ino       ), "show inodes and number of hard links"       do @puts = :ino ; @wds ||= 8 ; @wdu ||= 2 ; end
    option %w(+ wider     ), "widen fields in long output format"         do @wdu and @wdu += 2 ; @wds and @wds += @puts != :ls ? 4 : 3 ; end
    option %w(/ slash     ), "append a slash to directory names"          do @slash = true ; end
    option %w(l lines     ), "surround block by 'lines { |$_,$.| ... }'"  do |blk| @lines = :plain ;                 @block = blk ; end
    option %w(L reallines ), "same as -l but stop at any null character"  do |blk| @lines = :plain ; @real = true ;  @block = blk ; end
    option %w(g grep      ), "grep files (implies -pL)"                   do |blk| @lines = :grep  ;                 @block = blk ; end
    option %w(G igrep     ), "case insensitive grep"                      do |blk| @lines = :grep  ; @icase = true ; @block = blk ; end
    option %w(b binary    ), "grep even binary files"                     do @binary = true ; end
    option %w(C no-vcs    ), "prune version control dirs (CVS/.svn/.git)" do @vcs = true ; end
    option %w(W no-swap   ), "ignore Vim swapfiles"                       do @vim = true ; end
    option %w(k skip      ), "filenames to skip"                          do |rgx| @skip = rgx ; end
    option %w(D demand    ), "skip all filenames but these"               do |rgx| @demand = rgx ; end
    option %w(e ext       ), "skip all filename extensions but these"     do |lst| @ext = lst ; end
    option %w(I visible   ), "skip all hidden (starting with .dot)"       do @visible = true ; end
    option %w(a all       ), "all, including hidden (starting with .dot)" do @visible = false ; end
    option %w(i icase     ), "ignore case in file and path matches"       do @icase = true ; end
    option %w(N nodirs    ), "skip directories"                           do @nodirs = true ; end
    option %w(B begin     ), "eval block before begin"                    do |blk| @blkbegin = blk ; end
    option %w(E end       ), "eval block after end"                       do |blk| @blkend   = blk ; end
    option %w(f file      ), "read block expression from file"            do |nam| @block = File.open nam do |f| f.each { |l| l.chomp! } end ; end
    option %w(K encoding  ), "encoding extern[:intern] (same as ruby -E)" do |str| e, i = str.split ":", 2 ; set_encoding e, i ; end
    option %w(  width-user), "width of user field"                        do |num| @wdu = num.to_i.nonzero? ; end
    option %w(  width-size), "width of size field"                        do |num| @wds = num.to_i.nonzero? ; end

    def initialize args
      @params = {}
      envopts = ENV[ "RBFIND_OPTIONS"]
      if envopts then
        e = []
        envopts.scan /"((?:[^"\\]|\\.)*)"|'([^']*)'|(\S+)/ do
          e.push $1 ? (eval $1) : ($2 || $3)
        end
        args.unshift *e
      end
      super args
      build_block
    end

    def run
      if @show then
        show
      else
        execute
      end
    end

    private

    INDENT = " "*2

    def long_fmt ug_bang, grp, time, opath, co
      b = "!" if ug_bang
      g = "_" if grp
      [
        "spcsep stype+modes,",
        [
          "user#{b}.w#@wdu, group#{b}.w#@wdu,",
          "size.w#{g}#@wds, #{time},",
          "#{opath} + #{co ? 'carrow' : 'arrow'}.to_s",
        ]
      ]
    end

    def build_re str, flags
      (Regexp.new str, flags).inspect
    end

    def build_re_ext flags
      exts = @ext.split(/ +|,/).map { |e| e.delete_prefix! "." ; e }
      ej = exts.join '|'
      str = '\A\.(' + ej + ')\z'
      (Regexp.new str, flags).inspect
    end

    def treat_last_arg_as_file
      l = @args.last
      not l or
        File.exist? l or
        l.start_with? "." or
        l !~ /[;<>{}\[\]()*?'"!&|~ ]/ or
        l =~ %r(/)
    end

    def join_code a, ind = 0
      case a
      when Array then
        a.map { |e| join_code e, ind + 1 }.join "\n"
      else
        INDENT * ind + a
      end
    end

    def build_block
      co = color_on $stdout
      opath = co ? "cpath" : "path"
      @slash and opath << "!"
      case @lines
      when :plain then
        @block = [ @block]
        @puts and @block = [ "if (", @block, ") then", [ "colsep #{opath}, num, line"], "end" ]
        @real and @block.unshift "break if ~/\\0/o"
        @block = [ "lines { |line,num|", [ "$_, $. = line, num"], @block, "}"]

      when :grep then
        ic = Regexp::IGNORECASE if @icase
        color = ", true" if co
        @block = [ "grep %r#{build_re @block, ic}#{color}"]
        @block.push "$stdout.flush" unless $stdout.tty?
        @binary or @block = [ "unless binary? then", @block, "end"]

      else
        unless @block then
          unless @puts then
            if treat_last_arg_as_file then
              @puts = true
            else
              @block = @args.pop
            end
          end
          if @puts then
            cond = @block
            @block = case @puts
              when :ls  then long_fmt false, false, "mtime.lsish", opath, co
              when :alt then long_fmt true,  true,  "mtime.long",  opath, co
              when :hum then long_fmt true,  true,  "mage.t.r4",   opath, co
              when :ino then [ "spcsep ino.w8, nlink.w2, #{opath}"]
              else           [ "puts #{opath}"]
              end
            @block = [ "if (", [ cond], ") then", @block, "end"] if cond
          end
        end

      end

      osic = Regexp::IGNORECASE if File::ALT_SEPARATOR || @icase
      @skip   and @block.unshift "done if     name =~ #{build_re @skip,   osic}"
      @demand and @block.unshift "done unless name =~ #{build_re @demand, osic}"
      @ext    and @block.unshift "done unless ext  =~ #{build_re_ext osic}"

      @visible and @block.unshift "done unless visible?"
      @nodirs  and @block.unshift "done if dir?"
      @vcs     and @block.unshift "no_vcs"
      @vim     and @block.unshift "done if vimswap?"

      @params[ :error] = proc do
        case $!
        when Errno::EPIPE         then raise
        when NameError, TypeError then raise
        when ArgumentError        then raise
        else                           show_error $!
        end
      end
    end

    private

    def usage
      puts <<~EOT
        Usage:

          rbfind [options] path... 'block'

      EOT
      self.class.usage
      puts <<~'EOT'

        The last argument is a block that will be executed on every found
        file object. It may be omitted; then "puts path" is assumed, or
        "puts cpath" in case the output is a terminal.

        Default sort order is by name.
      EOT
    end

    def usage_examples
      usage
      puts <<~'EOT'
        Examples:
          $ rbfind -p 'file and age < 5.m'
          $ rbfind -p 'file and age > 1.d'
          $ rbfind -p '(90.d .. 183.d) === age'

          $ rbfind -Cg require
          $ rbfind -Cp
          $ rbfind 'filesize < 100.kB and grep /require/'
          $ rbfind -g 'define\s*ALLOC_N'
          $ rbfind myproject -e rb -l '~/require/ and puts $_'

          $ rbfind -pe '.rb c h'
          $ rbfind /usr/include -e .h -g EACCES
          $ rbfind -d -m3 -- /mnt/data
          $ rbfind 'filesize > 10.MiB and colsep size.to_hib, path'

          $ rbfind -U "name =~ /^\.*/ ; $'.downcase"
          $ rbfind -B '$s=0' -E 'puts $s.to_h' 'filesize {|s|$s+=s}'
          $ rbfind 'puts path if ext == ".rb"'
          $ rbfind -p 'ext == ".rb"'
          $ rbfind /usr/include -p -D '\.h$' -l '~/EACCES/'
          $ rbfind /usr/include -pD 'pg|pq|postgres' dir
          $ rbfind 'no_svn ; puts path'
          $ rbfind 'prune if name == ".svn" ; puts path'
          $ rbfind -p 'prune if name == ".svn"'
          $ rbfind myproject 'name[/\.rb$/] and lines { |l,i| l=~/require/ and puts l }'
          # rbfind /etc 'lines { |l,| l["192.168."] and (puts path ; break) }'
          $ rbfind /etc 'readable? or raise "Access denied: #{path}" ;
          >              lines { |l,| l["192.168."] and (puts path ; break) }'

          $ rbfind 'col_sep stype+modes, size.w10, path'
          $ rbfind 'tab_sep stype+modes, size.w10, path'
          $ rbfind 'spc_sep stype+modes, size.to_h, user, group, mtime.lsish, path'
          $ rbfind 'p stype+modes, size.to_h, user, group, mtime.lsish, path'
          $ rbfind 'p stype+modes, size.to_h, user, group, mtime!, path'
          $ rbfind 'p stype+modes, size.to_h, user, group, mtime.i, path'
          $ rbfind 'p mtime.u, path'
          $ rbfind 'p modes, user.w8, group.w8, size.w8, cpath + carrow.to_s'

          $ rbfind 'p digest_md5, size.w8, path'
          $ rbfind 'p digest_sha256, size.w8, path'

          $ rbfind 'rename name.downcase'
          $ rbfind 'ext == ".tgz" and rename without_ext+".tar.gz"'

          See the RbFind documentation or the "rbfind.rb" source file for more
          sophisticated examples and for a full list of file examination methods.

          Valid units are 1.s, 1.m, 1.h, 1.d, 1.w for time values and
          1.kB == 1000, 1.kiB == 1024, 1.MB, 1.MiB for file sizes.
      EOT
    end

    def set_encoding extern, intern = nil
      Encoding.default_external = extern if extern and not extern.empty?
      Encoding.default_internal = intern if intern and not intern.empty?
      [ $stdin, $stdout, $stderr].each do |io|
        io.set_encoding extern, intern
      end
    end

    def color_on stream
      @color.nil? ? !File::ALT_SEPARATOR && stream.tty? : @color
    end


    def show_error e
      co = color_on $stderr
      $stderr.puts co ? "\e[31m#{e.class}: \e[1m#{e}\e[m" : "#{e.class}: #{e}"
    end

    def error_handle
      if @verbose then
        yield
      else
        begin
          yield
        rescue ArgumentError
          show_error $!
          if $!.message[ "invalid byte sequence"] then
            $stderr.puts <<~EOT
              Hint: Try to give a different default encoding by explicitly setting one or
              by changing the locale.

                $ rbfind -K ascii-8bit ...
                $ LC_ALL="C" rbfind ...

              Alternatively, you may prefer to scrub the invalid encodings yourself.

                $ rbfind -P 'name.scrub =~ /Fu.ball/'

            EOT
          end
          exit 1
        rescue
          show_error $!
          exit 1
        rescue NoMemoryError, ScriptError, SignalException
          show_error $!
          exit 2
        end
      end
    end

    def execute
      error_handle do
        eval @blkbegin if @blkbegin
        b = join_code @block
        Walk.run *@args, **@params do instance_eval b end
        eval @blkend   if @blkend
      end
    end

    def show
      puts "arguments:"
      @args.each { |a| puts_val a }.any?             or puts_val "(none)"
      puts "parameters:"
      @params.each { |k,v| puts_val k, "=", v }.any? or puts_val "(none)"
      puts "block:"
      c = join_code @block, 1
      puts c
    end

    def puts_val *args
      l = [ INDENT, *args].join ""
      puts l
    end

  end


  class Entry

    # Alias the question marks away from all method names because
    # they're a nuisance on the command line.
    alias hidden       hidden?
    alias visible      visible?
    alias broken_link  broken_link?
    alias broken       broken?
    alias dir          dir?
    alias binary       binary?
    alias bin          bin?
    alias vimswap      vimswap?

    def blockdev        ; blockdev?         ; end
    def chardev         ; chardev?          ; end
    def directory       ; directory?        ; end
    def executable      ; executable?       ; end
    def executable_real ; executable_real?  ; end
    def file            ; file?             ; end
    def grpowned        ; grpowned?         ; end
    def owned           ; owned?            ; end
    def pipe            ; pipe?             ; end
    def readable        ; readable?         ; end
    def readable_real   ; readable_real?    ; end
    def setgid          ; setgid?           ; end
    def setuid          ; setuid?           ; end
    def socket          ; socket?           ; end
    def sticky          ; sticky?           ; end
    def symlink         ; symlink?          ; end
    def writable        ; writable?         ; end
    def writable_real   ; writable_real?    ; end
    def zero            ; zero?             ; end

    # convenient digest and time format methods
    alias method_missing_orig method_missing
    def method_missing sym, *args, &block
      case sym.to_s
      when /\Adigest_(.*)/, /\A([a-z]+[0-9]+)\z/ then
        m = $1
        d = begin
          Digest.const_get m.upcase
        rescue NameError
          if m =~ /sha\d\d\d/ then m = "sha2" end
          require "digest/#{m}" and retry
          raise
        end
        e = d.new
        read 0x1000_0000 do |b| e.update b end
        e.hexdigest
      when /\A([amc]time)!\z/ then
        (send $1).strftime "%Y-%m-%d %H:%M:%S %z"
      else
        method_missing_orig sym, *args, &block
      end
    end

  end

end


class Time

  # autoload several formating methods
  def method_missing sym, *args, &block
    require "time" and return send sym, *args, &block
    super
  end

  # several common schemes
  def i ; iso8601   ; end
  def x ; xmlschema ; end
  def r ; rfc822    ; end
  def u ; utc.strftime "%Y-%m-%d %H:%M:%S" ; end

end


class Integer
  # convenient formatting, right justification
  def method_missing sym, *args
    case sym
    when /\Aw(\d+)/  then "%#{$1}d" % self
    when /\Aw_(\d+)/ then to_g.rjust $1.to_i
    else                  super
    end
  end
end

class String
  # convenient formatting, left and right justification
  def method_missing sym, *args
    case sym
    when /\Aw_?(\d+)/ then ljust $1.to_i
    when /\Ar_?(\d+)/ then rjust $1.to_i
    else                   super
    end
  end
  # conventient date/time construction
  def time
    Time.parse self
  end
end

class NilClass
  # This makes it very easy to compare the return value of `filesize'.
  def <  oth ; false ; end
  def <= oth ; false ; end
  def >  oth ; false ; end
  def >= oth ; false ; end
  def between? min, max ; false ; end

  def method_missing sym, *args
    case sym
    when /\A[wr]_?(\d+)/ then " "*$1.to_i
    else                      super
    end
  end
end

class TrueClass
  def <=> oth
    oth == true ? 0 : oth == false ? 1 : nil
  end
  include Enumerable
end

class FalseClass
  def <=> oth
    oth == false ? 0 : oth == true ? -1 : nil
  end
  include Enumerable
end

class Proc
  def to_s
    "#<%s:0x%08x>" % [ self.class, object_id]
  end
end


RbFind::RbFindAppl.run

